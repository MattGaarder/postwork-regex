// ──────────────────────────────────────────────────────────────────────────────
// - `generator client` tells Prisma to generate a TypeScript client you import
//   as `import { PrismaClient } from '@prisma/client'`.
// - `datasource db` configures the actual database connection.
// ──────────────────────────────────────────────────────────────────────────────
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"           // Using Postgres; can also be mysql, sqlite, etc.
  url      = env("DATABASE_URL")    // Read the connection string from .env
}

// ──────────────────────────────────────────────────────────────────────────────
// MODEL: User
// - Each `model` maps to a DB table.
// - Scalars like Int/String/DateTime map to columns.
// - Relations are declared with @relation. If a model participates in *multiple*
//   relations to the same model (User ↔ many things), name each relation so
//   Prisma can pair them correctly.
// ──────────────────────────────────────────────────────────────────────────────
model User {
  id             Int              @id @default(autoincrement())
  email          String           @unique
  passwordHash   String
  name           String?          // Optional = NULL allowed
  createdAt      DateTime         @default(now())
  // Relations to other models (each with its own name)
  // Inverse relation fields (arrays) — no FK columns here, just virtual mappings
  projects       Project[]        @relation("OwnedProjects")      
  memberships    ProjectMember[]  @relation("ProjectMemberships")
  submissions    Submission[]     @relation("AuthoredSubmissions")
  comments       Comment[]        @relation("UserComments")
  reactions      Reaction[]       @relation("UserReactions")
  userStat       UserStat?
}

model Project {
  id          Int              @id @default(autoincrement())
  ownerId     Int              // FK column -> User.id
  // Relation to the owner. Because User has multiple relations, we NAME this pair.
  owner       User             @relation("OwnedProjects", fields: [ownerId], references: [id])
  name        String
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt @default(now())
  // Inverse sides (arrays) — Prisma figures out FK via the other models
  members     ProjectMember[]
  submissions Submission[]
}

// ──────────────────────────────────────────────────────────────────────────────
// JOIN/TABLE: ProjectMember
// - Classic many-to-many *with payload* pattern (a membership has a role).
// - We keep a composite unique to prevent duplicates (same user in same project).
// ──────────────────────────────────────────────────────────────────────────────
model ProjectMember {
  id        Int      @id @default(autoincrement())
  project   Project  @relation(fields: [projectId], references: [id]) // FK -> Project.id
  projectId Int
  user      User     @relation("ProjectMemberships", fields: [userId], references: [id]) // FK -> User.id
  userId    Int
  role      MemberRole @default(REVIEWER)
  @@unique([projectId, userId]) // Prevent duplicate memberships
}

// ──────────────────────────────────────────────────────────────────────────────
// ENUM: MemberRole
// - A fixed set of allowed string-like values. Safer than a free-text "role".
// - Generates a TS enum-like type in @prisma/client for autocompletion.
// ──────────────────────────────────────────────────────────────────────────────
enum MemberRole {
  OWNER
  MAINTAINER
  REVIEWER
}

model Submission {
  id          Int        @id @default(autoincrement())
  project     Project    @relation(fields: [projectId], references: [id])
  projectId   Int
  title       String
  language    String     // Could become an enum later (JAVASCRIPT|PYTHON|JAVA)
  code        String     // Store the raw source code (text)
  author      User       @relation("AuthoredSubmissions", fields: [authorId], references: [id])
  authorId    Int
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  comments    Comment[]   // Inverse: all comments for this submission
}


// Optional but recommended: make parent a real self-relation
// ──────────────────────────────────────────────────────────────────────────────
// MODEL: Comment with self-relation for threads
// - Self-relation lets a comment have a parent (for threads) and children.
// - `parentId` is optional; root comments have parentId = NULL.
// ──────────────────────────────────────────────────────────────────────────────
model Comment {
  id            Int         @id @default(autoincrement())
  submission    Submission  @relation(fields: [submissionId], references: [id])
  submissionId  Int
  author        User        @relation("UserComments", fields: [authorId], references: [id])
  authorId      Int
  body          String
  line          Int
         

  // Self-relation (threading). Use a named relation so both sides pair up.
  parentId      Int?
  parent        Comment?    @relation("CommentThread", fields: [parentId], references: [id])
  children      Comment[]   @relation("CommentThread")
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  reactions     Reaction[]
  pointsAwarded Int         @default(0)
}


// ──────────────────────────────────────────────────────────────────────────────
// MODEL: Reaction
// - Simple “upvote/like” entity. Unique constraint prevents double-voting.
// ──────────────────────────────────────────────────────────────────────────────
model Reaction {
  id        Int      @id @default(autoincrement())
  comment   Comment  @relation(fields: [commentId], references: [id])
  commentId Int
  user      User     @relation("UserReactions", fields: [userId], references: [id])
  userId    Int
  kind      String   // e.g. "upvote" — could be an enum later

  @@unique([commentId, userId, kind]) // One reaction per user per kind per comment
}

// ──────────────────────────────────────────────────────────────────────────────
// MODEL: UserStat (1:1 with User)
// - Denormalized counters for quick reads (leaderboards, profile badges).
// - You update these in your API whenever a comment/reaction happens.
// ──────────────────────────────────────────────────────────────────────────────
model UserStat {
  userId        Int    @id
  user          User   @relation(fields: [userId], references: [id])
  points        Int    @default(0)
  commentsCount Int    @default(0)
  badges        String? // JSON or CSV (JSON recommended if you need structure)
}