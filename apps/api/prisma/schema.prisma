// ──────────────────────────────────────────────────────────────────────────────
// - `generator client` tells Prisma to generate a TypeScript client you import
//   as `import { PrismaClient } from '@prisma/client'`.
// - `datasource db` configures the actual database connection.
// ──────────────────────────────────────────────────────────────────────────────
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Using Postgres; can also be mysql, sqlite, etc.
  url      = env("DATABASE_URL") // Read the connection string from .env
}

// ──────────────────────────────────────────────────────────────────────────────
// ENUM: MemberRole // Lanuage
// - A fixed set of allowed string-like values. Safer than a free-text "role".
// - Generates a TS enum-like type in @prisma/client for autocompletion.
// ──────────────────────────────────────────────────────────────────────────────
enum MemberRole {
  OWNER
  MAINTAINER
  REVIEWER
}

enum Language {
  JAVASCRIPT
  PYTHON
  JAVA
}

// ──────────────────────────────────────────────────────────────────────────────
// MODEL: User
// - Each `model` maps to a DB table.
// - Scalars like Int/String/DateTime map to columns.
// - Relations are declared with @relation. If a model participates in *multiple*
//   relations to the same model (User ↔ many things), name each relation so
//   Prisma can pair them correctly.
// ──────────────────────────────────────────────────────────────────────────────
model User {
  id           Int             @id @default(autoincrement())
  email        String          @unique
  passwordHash String
  name         String? // Optional = NULL allowed
  createdAt    DateTime        @default(now())
  // Relations to other models (each with its own name)
  // Inverse relation fields (arrays) — no FK columns here, just virtual mappings
  projects     Project[]       @relation("OwnedProjects") // User → Project (owner)
  memberships  ProjectMember[] @relation("ProjectMemberships") // User ↔ ProjectMember
  versions     Version[]       @relation("VersionAuthors") // User → Version (author)
  comments     Comment[]       @relation("UserComments") // User → Comment (author)
  reactions    Reaction[]      @relation("UserReactions") // User → Reaction
  userStat     UserStat?


  // @@index([...]) defines a database index on one or more columns - are performance helpers for databases.
  // Without an index, when you run a query like: SELECT * FROM "Comment" WHERE "versionId" = 3;
  // the database might have to scan every single row in the table to find the matches — this is called a full table scan.
  // With an index on versionId, the database can look up those rows much faster, because it maintains a sorted list of pointers to rows that share that value (think of it like the index at the back of a book).
  @@index([email])
}

model Project {
  id          Int             @id @default(autoincrement())
  ownerId     Int // FK column -> User.id
  // Relation to the owner. Because User has multiple relations, we NAME this pair.
  owner       User            @relation("OwnedProjects", fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  name        String
  description String?
  language    Language
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @default(now()) @updatedAt
  // RELATIONS - inverse sides (arrays) — Prisma figures out FK via the other models
  members     ProjectMember[]
  versions    Version[]

  @@index([ownerId])
  @@index([name])
}

// ──────────────────────────────────────────────────────────────────────────────
// JOIN/TABLE: ProjectMember
// - Classic many-to-many *with payload* pattern (a membership has a role).
// - We keep a composite unique to prevent duplicates (same user in same project).
// ──────────────────────────────────────────────────────────────────────────────
model ProjectMember {
  id        Int        @id @default(autoincrement())
  projectId Int
  userId    Int
  role      MemberRole @default(REVIEWER)

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user    User    @relation("ProjectMemberships", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([projectId, userId]) // no duplicate memberships
  @@index([userId])
  @@index([projectId])
}

model Version {
  id        Int     @id @default(autoincrement())
  projectId Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  authorId Int?
  author   User? @relation("VersionAuthors", fields: [authorId], references: [id], onDelete: SetNull)

  language String
  code  String // the current text shown in Monaco

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  comments Comment[] @relation("VersionComments")

  @@index([projectId])
  @@index([authorId])
}

// Optional but recommended: make parent a real self-relation
// ──────────────────────────────────────────────────────────────────────────────
// MODEL: Comment with self-relation for threads
// - Self-relation lets a comment have a parent (for threads) and children.
// - `parentId` is optional; root comments have parentId = NULL.
// ──────────────────────────────────────────────────────────────────────────────
model Comment {
  id           Int        @id @default(autoincrement())
  versionId    Int
  version      Version    @relation("VersionComments", fields:[versionId], references: [id], onDelete: Cascade)


  lineStart    Int?
  lineEnd      Int?
  content      String     

  authorId     Int
  author       User       @relation("UserComments", fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  parentId     Int?
  parent       Comment?   @relation("CommentThread", fields: [parentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  children     Comment[]  @relation("CommentThread")

  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now())

  @@index([versionId])
  @@index([authorId])
  @@index([parentId])

  @@index([lineStart])
  @@index([lineEnd])
  // A composite index that helps “find comments covering line X”
  @@index([versionId, lineStart, lineEnd])
}

// ──────────────────────────────────────────────────────────────────────────────
// MODEL: Reaction
// - Simple “upvote/like” entity. Unique constraint prevents double-voting.
// ──────────────────────────────────────────────────────────────────────────────
model Reaction {
  id        Int    @id @default(autoincrement())
  commentId Int
  userId    Int
  kind      String // e.g. "upvote"

  // comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user User @relation("UserReactions", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([commentId, userId, kind])
  @@index([userId])
  @@index([commentId])
}

// ──────────────────────────────────────────────────────────────────────────────
// MODEL: UserStat (1:1 with User)
// - Denormalized counters for quick reads (leaderboards, profile badges).
// - You update these in your API whenever a comment/reaction happens.
// ──────────────────────────────────────────────────────────────────────────────
model UserStat {
  userId        Int     @id
  user          User    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  points        Int     @default(0)
  commentsCount Int     @default(0)
  badges        String?

  // could add computed indexes later if needed
}
